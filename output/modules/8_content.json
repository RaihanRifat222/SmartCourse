{
  "module_content": {
    "module_id": "8",
    "sections": [
      {
        "section_id": "1",
        "title": "Understanding Encapsulation in OOP",
        "conceptual_explanation": "Encapsulation is a fundamental concept in Object-Oriented Programming (OOP) that involves bundling the data (attributes) and methods (functions) that operate on the data into a single unit, known as a class. It exists to protect the internal state of an object from unintended interference and misuse. Think of encapsulation like a capsule that contains medicine; the capsule protects the medicine inside from the outside environment, ensuring it works as intended. In programming, encapsulation allows you to control how the data is accessed and modified, which helps maintain the integrity of the object. You may have learned about variables and functions separately, but encapsulation combines them into a cohesive structure, making your code more organized and easier to manage.",
        "applied_explanation": "In practice, encapsulation works by defining a class with private attributes and providing public methods to access and modify these attributes. For example, if you have a class called 'BankAccount', you might want to keep the balance attribute private to prevent direct access from outside the class. Instead, you would create public methods, known as getters and setters, to allow controlled access to the balance. When implementing encapsulation, pay attention to the visibility of your class members; use 'private' for attributes that should not be accessed directly and 'public' for methods that provide access. A common beginner mistake is to make attributes public, which defeats the purpose of encapsulation and can lead to unintended changes to the object's state.",
        "example": "Let's create a simple 'BankAccount' class to illustrate encapsulation. First, we define the class and its private attribute 'balance'. Then, we implement a getter method 'getBalance()' to retrieve the balance and a setter method 'deposit(amount)' to modify the balance. Here\u2019s the code:\n\nclass BankAccount {\n    private double balance; // This is a private attribute\n\n    public BankAccount(double initialBalance) { // Constructor to initialize balance\n        this.balance = initialBalance;\n    }\n\n    public double getBalance() { // Getter method to access balance\n        return balance;\n    }\n\n    public void deposit(double amount) { // Setter method to modify balance\n        if (amount > 0) { // Check if the deposit amount is valid\n            balance += amount; // Update the balance\n        }\n    }\n}\n\nIn this example, the 'balance' attribute is private, meaning it cannot be accessed directly from outside the class. The 'getBalance()' method allows us to view the balance, while the 'deposit()' method allows us to add money to the account, ensuring that only valid amounts are added.",
        "practice_questions": [
          {
            "question": "What is encapsulation in OOP?",
            "type": "short_answer"
          },
          {
            "question": "Why is it important to keep class attributes private?",
            "type": "short_answer"
          },
          {
            "question": "You are creating a class for a 'Car'. How would you implement encapsulation for the 'speed' attribute? Provide a brief explanation.",
            "type": "scenario"
          }
        ]
      },
      {
        "section_id": "2",
        "title": "Implementing Getters and Setters",
        "conceptual_explanation": "Getters and setters are methods used to access and modify the private attributes of a class. They are essential for encapsulation because they provide a controlled way to interact with the data. Getters allow you to retrieve the value of a private attribute, while setters enable you to change its value. This practice exists to ensure that any changes to the data can be validated or processed before they are applied. Imagine you have a remote control for a TV; the buttons (getters and setters) allow you to change the channel or volume without directly accessing the internal components of the TV. This separation of concerns helps maintain the integrity of the object's state and makes your code more maintainable. You may have learned about methods before, but getters and setters specifically focus on managing access to an object's data.",
        "applied_explanation": "To implement getters and setters, you define public methods within your class that correspond to each private attribute. For instance, if you have a private attribute 'age', you would create a getter method 'getAge()' to return the age and a setter method 'setAge(int age)' to modify it. When writing these methods, pay attention to the data types and any validation you might need. A common beginner mistake is to forget to include validation in the setter methods, which can lead to invalid data being set. For example, if you set an age to a negative number, it doesn't make sense. Therefore, you should check the value in the setter before applying it.",
        "example": "Let's extend our 'BankAccount' class by adding a 'holderName' attribute with its getter and setter. Here\u2019s how it looks:\n\nclass BankAccount {\n    private String holderName; // Private attribute for account holder's name\n    private double balance;\n\n    public BankAccount(String name, double initialBalance) {\n        this.holderName = name;\n        this.balance = initialBalance;\n    }\n\n    public String getHolderName() { // Getter for holderName\n        return holderName;\n    }\n\n    public void setHolderName(String name) { // Setter for holderName\n        if (name != null && !name.isEmpty()) { // Validate name\n            holderName = name;\n        }\n    }\n}\n\nIn this example, the 'holderName' attribute is private, and we have a getter 'getHolderName()' to access it. The setter 'setHolderName(String name)' checks if the provided name is not null or empty before updating the attribute, ensuring that the account holder's name is always valid.",
        "practice_questions": [
          {
            "question": "What are getters and setters used for?",
            "type": "short_answer"
          },
          {
            "question": "How would you implement a setter for an attribute 'email' in a class? Provide a brief explanation.",
            "type": "scenario"
          },
          {
            "question": "Which of the following is a benefit of using setters? \nA) They allow direct access to private attributes. \nB) They can include validation logic. \nC) They are not necessary in OOP. ",
            "type": "mcq",
            "options": [
              "A",
              "B",
              "C"
            ],
            "correct_answer": "B",
            "explanation": "Setters can include validation logic to ensure that only valid data is assigned to the private attributes, which helps maintain the integrity of the object's state."
          }
        ]
      }
    ]
  }
}