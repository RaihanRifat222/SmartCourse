{
  "module_content": {
    "module_id": "10",
    "sections": [
      {
        "section_id": "1",
        "title": "Understanding Polymorphism in OOP",
        "conceptual_explanation": "Polymorphism is a core concept in Object-Oriented Programming (OOP) that allows objects to be treated as instances of their parent class, even if they are actually instances of a child class. This concept exists to enable flexibility and the ability to use a single interface to represent different underlying forms (data types). Think of it like a remote control that can operate different devices like a TV, DVD player, or sound system. You use the same buttons (interface) to control different devices (objects). In programming, polymorphism allows methods to do different things based on the object that it is acting upon, which is crucial for writing reusable and maintainable code. You may have learned about classes and objects; polymorphism builds on that by allowing methods to be defined in a way that they can operate on different types of objects seamlessly.",
        "applied_explanation": "In practice, polymorphism can be implemented in two main ways: method overriding and method overloading. Method overriding occurs when a child class provides a specific implementation of a method that is already defined in its parent class. To see how this works, consider a scenario where you have a base class called 'Animal' with a method 'makeSound'. The child classes 'Dog' and 'Cat' can override this method to provide their specific sounds. When you call 'makeSound' on an 'Animal' reference that points to a 'Dog' object, it will execute the 'Dog's' version of 'makeSound'. Pay attention to the fact that the method signature remains the same, but the behavior changes based on the object type. A common beginner mistake is to forget to use the 'override' keyword in languages that require it, which can lead to confusion about which method is being called.",
        "example": "Let's look at a simple example in Java. We have a base class 'Animal' with a method 'makeSound'. Then, we create two subclasses, 'Dog' and 'Cat', that override this method. Here\u2019s the code:\n\nclass Animal {\n    void makeSound() {\n        System.out.println(\"Animal makes a sound\");\n    }\n}\n\nclass Dog extends Animal {\n    @Override\n    void makeSound() {\n        System.out.println(\"Dog barks\");\n    }\n}\n\nclass Cat extends Animal {\n    @Override\n    void makeSound() {\n        System.out.println(\"Cat meows\");\n    }\n}\n\nIn the main method, we can create an Animal reference:\n\npublic class Main {\n    public static void main(String[] args) {\n        Animal myDog = new Dog();\n        Animal myCat = new Cat();\n        myDog.makeSound(); // Outputs: Dog barks\n        myCat.makeSound(); // Outputs: Cat meows\n    }\n}\n\nHere, 'myDog' and 'myCat' are both of type 'Animal', but they call their respective overridden methods, demonstrating polymorphism.",
        "practice_questions": [
          {
            "question": "What is polymorphism in OOP?",
            "type": "short_answer"
          },
          {
            "question": "Explain how method overriding works in polymorphism.",
            "type": "short_answer"
          },
          {
            "question": "You have a class 'Vehicle' with a method 'start'. You create subclasses 'Car' and 'Bike' that override 'start'. If you have a 'Vehicle' reference pointing to a 'Car' object, what will happen when you call 'start'?",
            "type": "scenario",
            "explanation": "The 'start' method of the 'Car' class will be executed, demonstrating polymorphism."
          }
        ]
      }
    ]
  }
}